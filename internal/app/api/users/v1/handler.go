// Generated by protoc-gen-tron.

package auth

import (
	"context"
	"fmt"
	"io"
	"net/http"

	"github.com/loghole/tracing/tracelog"
	"github.com/loghole/tron/transport"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"

	"github.com/gadavy/tx-example/internal/app/domain"
	"github.com/gadavy/tx-example/internal/app/ports"
	auth "github.com/gadavy/tx-example/pkg/api/auth/v1"
)

const (
	cookieName = "_vw_sx"
	setCookie  = "Set-Cookie"
)

type Implementation struct {
	auth.UnimplementedAuthAPIServer

	logger  tracelog.Logger
	service ports.AuthService
}

func NewImplementation(logger tracelog.Logger, service ports.AuthService) *Implementation {
	return &Implementation{
		logger:  logger,
		service: service,
	}
}

// GetDescription is a simple alias to the ServiceDesc constructor.
// It makes it possible to register the service implementation @ the server.
func (i *Implementation) GetDescription() transport.ServiceDesc {
	return auth.NewAuthAPIServiceDesc(i)
}

func (i *Implementation) AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if skip(r.URL.Path) {
			next.ServeHTTP(w, r)

			return
		}

		token, exists := i.readHTTPCookie(r)

		session, err := i.service.Authenticate(r.Context(), token)
		if err != nil && exists {
			http.SetCookie(w, cookie("", true))
		}

		if session != nil && err == nil {
			r = r.WithContext(domain.SessionToContext(r.Context(), session))

			w.Header().Set("X-Admin", "true")
		}

		if err != nil {
			i.logger.
				With("client-ip", r.RemoteAddr).
				With("client-user-agent", r.UserAgent()).
				With("req-url", r.URL.String()).
				Warnf(r.Context(), "can't authenticate request: %v", err)

			w.WriteHeader(http.StatusUnauthorized)
			_, _ = io.WriteString(w, http.StatusText(http.StatusUnauthorized))

			return
		}

		next.ServeHTTP(w, r)
	})
}

func (i *Implementation) readHTTPCookie(r *http.Request) (string, bool) {
	cookie, err := r.Cookie(cookieName)
	if err != nil {
		return "", false
	}

	return cookie.Value, true
}

func (i *Implementation) setGRPCCookie(ctx context.Context, value string, drop bool) error {
	cookie := cookie(value, drop)

	err := grpc.SetHeader(ctx, metadata.New(map[string]string{setCookie: cookie.String()}))
	if err != nil {
		return fmt.Errorf("can't set header: %w", err)
	}

	return nil
}

func cookie(value string, drop bool) *http.Cookie {
	const maxAge = 10 * 365 * 86400 // 10 years in seconds.

	cookie := &http.Cookie{
		Name:     cookieName,
		Value:    value,
		HttpOnly: true,
		Path:     "/",
		SameSite: http.SameSiteStrictMode,
		MaxAge:   maxAge,
	}

	if drop {
		cookie.MaxAge = -1
	}

	return cookie
}

func skip(path string) bool {
	switch path {
	case "/api/v1/auth/sign_in",
		"/api/v1/auth/sign_up":
		return true
	default:
		return false
	}
}
